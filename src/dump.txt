//TEST DIJKSTRA 1
int a = 0;
        List<List<Integer>> MAP_NODES = new ArrayList<List<Integer>>();

        //Create Matrix
        //you did it you crazy mf
        for (int i = 0; i < tileList.size(); i++){
            //Düğüm ekle
            String tiletype = tileList.get(i).getTILE_TYPE();
            List<Integer> intList = new ArrayList<>();
            MAP_NODES.add(intList);
            if (tiletype.equals("PATH")) {
                //komşuluk kontrolü
                if (i < 13) {
                    //ilk rowdaki komşuluklara bakarken üstte komşuları olamaz ve yanda da olamaz
                    //Sadece sağ ve sola bak
                    int left = i - 1;
                    int right = i + 1;
                    int down = i + 13;
                    Tiles tilesLeft = tileList.get(left);
                    Tiles tilesRight = tileList.get(right);
                    Tiles tilesDown = tileList.get(down);
                    for (int j = 0; j < tileList.size(); j++){
                        if (j == left && tilesLeft.getTILE_TYPE().equals("PATH")) {
                            MAP_NODES.get(i).add(left,BLOCK_H);
                        }
                        else if (j == right && tilesRight.getTILE_TYPE().equals("PATH")) {
                            MAP_NODES.get(i).add(right,BLOCK_H);
                        }
                        else if (j == down && tilesDown.getTILE_TYPE().equals("PATH")) {
                            MAP_NODES.get(i).add(down,BLOCK_H);
                        }else {
                            MAP_NODES.get(i).add(0);
                        }
                    }
                }
                //Son row
                else if ( i > 131) {
                    int left = i - 1;
                    int right = i + 1;
                    int up = i - 13;
                    Tiles tilesLeft = tileList.get(left);
                    Tiles tilesRight = tileList.get(right);
                    Tiles tilesUp = tileList.get(up);
                    for (int j = 0; j < tileList.size(); j++){
                        if (j == left && tilesLeft.getTILE_TYPE().equals("PATH")) {
                            MAP_NODES.get(i).add(left,BLOCK_H);
                        }
                        else if (j == right && tilesRight.getTILE_TYPE().equals("PATH")) {
                            MAP_NODES.get(i).add(right,BLOCK_H);
                        }
                        else if (j == up && tilesUp.getTILE_TYPE().equals("PATH")) {
                            MAP_NODES.get(i).add(up,BLOCK_H);
                        }else {
                            MAP_NODES.get(i).add(0);
                        }
                    }
                }
                //en soldaki
                else if (i == 65) {
                    int right = i + 1;
                    Tiles tilesRight = tileList.get(right);
                    for (int j = 0; j < tileList.size(); j++){
                        if (j == right && tilesRight.getTILE_TYPE().equals("PATH")) {
                            MAP_NODES.get(i).add(right,BLOCK_H);
                        }else {
                            MAP_NODES.get(i).add(0);
                        }
                    }
                }

                //en sağdaki
                else if (i == 103) {
                    int left = i + 1;
                    Tiles tilesLeft = tileList.get(left);
                    for (int j = 0; j < tileList.size(); j++){
                        if (j == left && tilesLeft.getTILE_TYPE().equals("PATH")) {
                            MAP_NODES.get(i).add(left,BLOCK_H);
                        }
                        MAP_NODES.get(i).add(0);
                    }
                }
                //other tiles
                else {
                    int left = i - 1;
                    int right = i + 1;
                    int down = i + 13;
                    int up = i - 13;
                    Tiles tilesLeft = tileList.get(left);
                    Tiles tilesRight = tileList.get(right);
                    Tiles tilesDown = tileList.get(down);
                    Tiles tilesUp = tileList.get(up);
                    for (int j = 0; j < tileList.size(); j++){
                        if (j == left && tilesLeft.getTILE_TYPE().equals("PATH")) {
                            MAP_NODES.get(i).add(left,BLOCK_H);
                        }
                        else if (j == right && tilesRight.getTILE_TYPE().equals("PATH")) {
                            MAP_NODES.get(i).add(right,BLOCK_H);
                        }
                        else if (j == down && tilesDown.getTILE_TYPE().equals("PATH")) {
                            MAP_NODES.get(i).add(down,BLOCK_H);
                        }
                        else if (j == up && tilesUp.getTILE_TYPE().equals("PATH")) {
                            MAP_NODES.get(i).add(up,BLOCK_H);
                        }else {
                            MAP_NODES.get(i).add(0);
                        }
                    }
                }
            }else {
                // row'u 0 la doldur
                for (int j = 0; j < tileList.size(); j++){
                    MAP_NODES.get(i).add(0);
                }
            }
        }

        print("TOTAL NODE SIZE: " + tileList.size());

        /*for (List<Integer> list : MAP_NODES) {
            for (int i : list) {
                System.out.print(i + "\t");
            }
            System.out.print("\n");
        }*/

        int[][] MAP_ADJ = MAP_NODES.stream().map(  u  ->  u.stream().mapToInt(i->i).toArray()  ).toArray(int[][]::new);


        print("MAP ADJ: ROW L \n" + MAP_ADJ.length);
        print("MAP ADJ: COL L \n" + MAP_ADJ[0].length);
        for (int[] map_matrix :  MAP_ADJ) {
            for (int j = 0; j <  MAP_ADJ[0].length; j++) {
                //System.out.print(map_matrix[j] + "\t");
            }
            //System.out.println("");
        }

        ShortestPath shortestPath = new ShortestPath(MAP_ADJ,4);
        shortestPath.dijkstra();